{% extends "index.html" %}

{% block content %}

                    <div class="container-fluid px-4">
                        <h1 class="mt-4">Numpy</h1>
                        <ol class="breadcrumb mb-4">
                            <li class="breadcrumb-item"><a href="/">Dashboard</a></li>
                            <li class="breadcrumb-item active">Numpy</li>
                        </ol>
                        <div class="card mb-4">
                            <div class="card-body">
                                <p class="mb-0">


<h3><strong>Numpy - ndarray </strong></h3>
<p>N-dimmentional array, czyli (lista/tablica) wielowymiarowa. R&oacute;żni się wielowymiarowością od 1 wymiarowej listy w Pythonie, operacje na ndarray są szybsze w odniesieniu na operacjach na listach wPythonie</p>
<p><br /><br /></p>
<h3><strong>Tworzenie ndarray</strong></h3>
<p><strong>Tablice jedno-wymiarowe </strong></p>
<p>Podstawowe komendy, kt&oacute;rymi tworzymy tablice to</p>
<ul>
<li>
<p>np.array(), w kt&oacute;rej podajemy wartości,</p>
</li>
<li>
<p>np.arange(), w kt&oacute;rej podajemy zakres jakim, chcemy uzupełnić tablice,oraz odstęp liczbowy między nimi,</p>
</li>
<li>
<p>oraz bardzo użyteczna funkcja w przypadku tworzenia wykres&oacute;w &ndash; np.linspace(), gdzie podajmy zakres liczbowy, oraz na ile liczb chcemy go podzielić:</p>
</li>
</ul>


<pre><code class="language-py">
a = np.array([1,3,5,7])
# array([1, 3, 5, 7])
b = np.arange(4)
# array([0, 1, 2, 3])
np.arange(2,10,1)
# array([2, 3, 4, 5, 6, 7, 8, 9])
np.linspace(0,10,6)
# array([ 0.,  2.,  4.,  6.,  8., 10.])
</code></pre>

<p><strong>Tworzenie tablicy wielo-wymiarowej</strong></p>
<ul>
<li>
<p>Ręcznie, za pomocą np.array()</p>
</li>
<li>
<p>Wykorzystać kolejną użyteczną funkcję, w celu uzupełnienia jej zerami &ndash; np.zeros() lub jedynkami np.ones() albo wartościami losowymi np.random.random()</p>
</li>
</ul>

<pre><code class="language-py">
c = np.array([[1,2,3],[4,5,6]])
# array([[1, 2, 3],
#       [4, 5, 6]])
d = np.zeros((2,3))
# array([[0., 0., 0.],
#       [0., 0., 0.]])
d = np.ones((2,3))
# array([[1., 1., 1.],
#       [1., 1., 1.]])
np.random.random((2,3))
# array([[0.16868203, 0.31090109, 0.7210469 ],
#       [0.0750029 , 0.08401428, 0.96992496]])
np.random.rand(5)
# tworzy tablicę z zakresu od 0 do 1
</code></pre>

<h3><strong>Macierz</strong></h3>

<p>Matrix może mieć&nbsp;rozmaite typy, ale : wszystkie elementy muszą być takie same.</p>
<p>Zbi&oacute;r jednakowo długich wektor&oacute;w to macierz. Tworzymy je w Pythonie jako złożenie list.</p>

<pre><code class="language-py">
numpy_matrix = np.array([[1,2,3], [5,7,11]])
numpy_matrix.shape\
>> (2, 3)
</code></pre>


<h3><strong>Operacje na tablicach</strong></h3>
<p>W NumPy, możemy wykonywać wszystkie podstawowe operacje matematyczne, takie jak dodawanie, odejmowanie, mnożenie itd.</p>
<p>Dodatkowo, mamy do dyspozycji użyteczne funkcje, sprawdzające jej rozmiar &ndash; shape, transponujące &ndash; T.</p>
<p>Możemy r&oacute;wnież, w łatwy spos&oacute;b, sprawdzać wartości poszczeg&oacute;lnych element&oacute;w i tworzyć maski.</p>
<p><br /><br /></p>
<pre><code class="language-py">
a = np.array([1,3,5,7])
b = np.arange(4)
c = np.array([[1,2,3],[4,5,6]])

a+b
# array([ 1,  4,  7, 10])
c+d
# array([[2., 3., 4.],
#       [5., 6., 7.]])
c**2
# array([[ 1,  4,  9],
#       [16, 25, 36]])
c.shape
# (2, 3)
c.T
# array([[1, 4],
#       [2, 5],
#       [3, 6]])
c > 3
# array([[False, False, False],
#       [ True,  True,  True]])

one_dim = np.array([1,2,3,4])
one_dim.shape # kształt (,4)
one_dim.ndim # liczba wymiarów – w tym przypadku 1 wymiar

two_dim = np.array([[100, 200, 50, 400], [50, 0, 0, 100], [350, 100, 50, 200]])
print("len: " + str(len(two_dim)))      # len tu nie rozumiem
print("shape: " + str(two_dim.shape))  # rozmiar, kształt tablicy
print("ndim: " + str(two_dim.ndim))   #ilość wymiarów
print("size: " + str(two_dim.size))  #ilość elementów
print("bajt-size: " + str(two_dim.itemsize))

len: 3
shape: (3, 4)
ndim: 2
size: 12
bajt-size: 4
</code></pre>

<h3><strong>Operacje Macierze</strong></h3>

<pre><code class="language-py">
matrix2 = np.array([
        [1,2,3],
        [0,8,10],
        [1,10,12]
])

#Suma wszystkich elementów to po prostu sum na obiekcie.
matrix2.sum()
>> 47

#Sumując kolumny, otrzymamy tutaj:
matrix2.sum(axis=0) #kolumny
>> array([ 2, 20, 25])

# A wiersze:
matrix2.sum(axis=1) # wiersze
>> array([ 6, 18, 23])

# Dodawanie wektorów. Wykonywane jest ono z użyciem operatora +.
np.array([1,2]) + np.array([8,9])
>> array([ 9, 11])

#Można też dodawać i mnożyć macierze.
np.array([
        [1,2],
        [3,4]
]) + \
np.array([
        [8,9],
        [10,11]
])
>> array([[ 9, 11],
       [13, 15]])

# Dostępny jest też tzw. iloczyn skalarny (ang. dot product).
np.array([
        [1,2],
        [3,4]
]).dot([1,1])
>> array([3, 7])
</code></pre>
                                <p></p>
<h3><strong>Funkcje wbudowane</strong></h3>


<pre><code class="language-py">
x = np.random.random((3,5))
x
# array([[0.43391468, 0.73430824, 0.92759808, 0.23966575, 0.16112573],
#       [0.85501039, 0.67383523, 0.45245038, 0.26001489, 0.86884395],
#       [0.17991555, 0.96628615, 0.22680872, 0.92979024, 0.52796391]])

print(x.sum())
print(x.min())
print(x.max())
print(x.mean())
# 8.437531894577779
# 0.1611257283125176
# 0.9662861490415007
# 0.5625021263051853
</code></pre>

<h3><strong>Indeksowanie</strong></h3>
<pre><code class="language-py">
a[2:]
# array([5, 7])
c[:1]
# array([[1, 2, 3]])
c[:1,1:]
# array([[2, 3]])
for x in c:
    print (x)
    for y in x:
        print(y)
# [4 5 6]
# 1
# 2
# 3
# [4 5 6]
# 4
# 5
# 6
for x in c.flat:
    print(x)
# 1
# 2
# 3
# 4
# 5
# 6
[x for x in c if x[1] < 3]
# [array([1, 2, 3])]
</code></pre>

<h3><strong>Macierz indeksowanie</strong></h3>
<p>Takie macierze i wektory są indeksowane z zachowaniem pythonowych właściwości, czyli np. mając macierz</p>



<pre><code class="language-py">
matrix1 = np.array([
        [1,2,3],
        [4,5,6],
        [7,8,9]
])

#możemy pobrać pierwszy wiersz takim indeksowaniem
matrix1[0, :]
>> array([1, 2, 3])

#a ostatnia kolumna to
matrix1[:, -1]
>> array([3, 6, 9])
</code></pre>

                                <h3><strong> Zmiana rozmiarów tablicy </strong></h3>


<p><b>shape</b> - kształt</p>
<p>Narzędzie kształtu daje krotkę wymiar&oacute;w szyku i może być używane do zmiany wymiar&oacute;w szyku.</p>

<p>(a). <span lang="pl-PL">Używanie shape do uzyskania wymiar&oacute;w tablicy</span></p>

<pre><code class="language-py">
my__1D_array = numpy.array([1, 2, 3, 4, 5])
print (my_1D_array.shape)
#(5,) -> 1 row and 5 columns

my__2D_array = numpy.array([[1, 2],[3, 4],[6,5]])
print (my_2D_array.shape)
#(3, 2) -> 3 rows and 2 columns
</code></pre>

<p>(b). Używanie shape do <b>zmiany</b> wymiar&oacute;w tablicy</p>
<pre><code class="language-py">
change_array = numpy.array([1,2,3,4,5,6])
change_array.shape = (3, 2)
print (change_array)

#Output
#   [[1 2]
#    [3 4]
#    [5 6]]
</code></pre>
<b>reshape</b>
<p>Narzędzie reshape nadaje nowy kształt tablicy bez zmiany jej danych. Tworzy nową tablicę i nie modyfikuje samej
    tablicy oryginalnej.</p>

<pre><code class="language-py">
my_array = numpy.array([1,2,3,4,5,6])
print (numpy.reshape(my_array,(3,2)))

#Output
#    [[1 2]
#    [3 4]
#    [5 6]]

# W NumPy : tablice w rozmaity sposób przekształcone (np. przez operację reshape())
#           często okazują się być różnymi widokami na te same dane. Dla przykładu:

In [39]: A = numpy.arange(24)

In [40]: A
Out[40]:
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
       17, 18, 19, 20, 21, 22, 23])

In [41]: B = A.reshape(6, 4)

In [42]: B
Out[42]:
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23]])
</code></pre>



<iframe src="https://trinket.io/embed/python/9e69b1ba24" width="100%" height="356" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>


                            </div>
                        </div>


                    </div>

{% endblock %}
